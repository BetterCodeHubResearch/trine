<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Trine Documentation</title>
    <style>
body {
    font-family: sans-serif;
}
    </style>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-64008323-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<body>
    <h1 id="trine">Trine</h1>
<p><a href="https://travis-ci.org/jussi-kalliokoski/trine"><img src="https://travis-ci.org/jussi-kalliokoski/trine.svg?branch=master" alt="Build Status"></a>
<a href="https://coveralls.io/r/jussi-kalliokoski/trine"><img src="https://img.shields.io/coveralls/jussi-kalliokoski/trine.svg" alt="Coverage Status"></a></p>
<blockquote>
<p>The library modern JavaScript doesn&#39;t deserve, but needs right now.</p>
</blockquote>
<p>Trine is a utility library geared at tapping the full potential of functional programming in JS, in the vein of <a href="https://lodash.com/">lodash</a>, <a href="http://underscorejs.org/">underscore</a> and <a href="http://ramdajs.com/">Ramda</a>.</p>
<p>See the <a href="http://jussi-kalliokoski.github.io/trine/docs/latest">latest docs/documentation</a> for a full API reference.</p>
<h2 id="why-">Why?</h2>
<p>At this point, you should be asking yourself: &quot;why yet another utility library&quot;, and you&#39;d be right in asking so. Ramda argues that lodash and underscore put the data in the wrong place: at the first parameter of the function, while it should be at the last position. They&#39;re both (subjectively) wrong: the natural place for data in JS is the <code>this</code> parameter.</p>
<p>Functional programming in JS is awkward. ES5 introduced some improvements, and ES6 introduces even more. However, even if you&#39;re writing ES6 today, you are probably still seeing code like this when attempting to write in a functional style:</p>
<pre><code class="lang-javascript">flatten(
    items
        .filter(isOk)
        .map(toOtherType)
)
</code></pre>
<p>And this is just a simple example. The data as an argument style just doesn&#39;t fit in well with the builtins of JS, and makes it hard to reason about the order of transformations. What you&#39;d really want to do is this:</p>
<pre><code class="lang-javascript">items
    .filter(isOk)
    .map(toOtherType)
    .flatten()
</code></pre>
<p>but extending the builtin prototypes is a bad practice, even in non-library code, and has caused numerous issues with standardizing new features to builtins in JS. The <a href="https://github.com/zenparsing/es-function-bind">function bind syntax proposal</a> fixes this issue. The previous example could be written as follows:</p>
<pre><code class="lang-javascript">items
    .filter(isOk)
    .map(toOtherType)
    ::flatten()
</code></pre>
<p>Much better. But that&#39;s not all. Let&#39;s imagine we had a custom <code>map</code> and <code>reduce</code> methods that passed each item as <code>this</code> to the transformer function, as well as some other helpers. This would allow us to compose using the builtins, as so:</p>
<pre><code class="lang-javascript">const characters = strings
    ::map(String.prototype.split::partial(&quot;&quot;))
    ::reduce(Array.prototype.concat)
    .sort()
    ::uniq();
</code></pre>
<p>But why stop there? ES6 introduces the concept of iterators to JS. Iterators are a protocol that most collection types in ES6 (Map, Set, Array, etc.) implement, by exposing a function under the <code>Symbol.iterator</code> symbol. This means you can also extend your custom collection types to support the same protocol, and generator functions support it too. Iterators are a very flexible abstraction over collections, and unlike memory-bound collections, can also represent infinite sets, such as the Fibonacci series or prime numbers. In a memory-bound collection an infinite number of items would require infinite memory.</p>
<p>Iterators, on the other hand, allow us to process only as much as we need. So let&#39;s say we wanted to find the first 5 common items (intersection) of two infinite sets, the Fibonacci series and the prime numbers. The following is a working example of Trine, as Trine&#39;s all collection methods are actually methods for iterables:</p>
<pre><code class="lang-javascript">function * fibonacci () {
    let i0 = 1;
    let i1 = 0;

    while ( true ) {
        yield i0;
        [i0, i1] = [i0 + i1, i0];
    }
}

function * primes () {
    const primes = new Set();
    yield 1;
    yield 2;

    loop: for ( let i = 3; true; i += 2 ) {
        for ( const prime of primes ) {
            if ( i % prime === 0 ) { continue loop; }
        }

        primes.add(i)
        yield i;
    }
}

const commonItems = fibonacci()
    ::intersection(primes(), sub)
    ::head(5)
    ::to(Array);
console.log(commonItems); // logs [1, 2, 3, 5, 13]
</code></pre>
<p>Using iterators also allows us to easily timebox even synchronous operations. Let&#39;s say we wanted to get the 1000 first common items, but we&#39;d be ok with less if it would block for too long:</p>
<pre><code class="lang-javascript">const deadline = Date.now() + 1000;
const commonItems = fibonacci()
    ::takeWhile(() =&gt; Date.now() &lt; deadline)
    ::intersection(primes(), sub)
    ::head(1000)
    ::to(Array);

if ( commonItems.length &lt; 1000 ) {
    console.error(&quot;Sorry, asked for 1000 items but got only %s :(&quot;, commonItems.length);
}

console.log(commonItems);
</code></pre>
<p>There are some other practical applications to this as well. Say we have a set of products, and we want to show a page that lists the first 15 items sorted ascending by price. If our product catalogue is prohibitively long, sorting all the items ascending by price would take too long. With iterators, however, we can perform this orders of magnitude faster than with in-memory collections. Trine ships with an implementation of the quicksort algorithm that works with iterators. Using this, we only do precise sorting for the 15 first items, as so:</p>
<pre><code class="lang-javascript">function byPrice (b) {
    return this.price - b.price;
}

const firstPageItems = products
    ::quickSort(byPrice)
    ::head(15)
    ::to(Array);
</code></pre>
<p>That&#39;s it! Most of the time you won&#39;t even have to be thinking about performance, because with iterators you can just compose the manipulations to produce the result you need and good performance will be the default. I welcome all micro-benchmarks, but doing less work will always be faster than doing more work.</p>
<h3 id="maybe">Maybe</h3>
<p>Iterators have one more trick up their sleeve. They provide a handy way to wrap missing data, instead of implementing error handling at every turn. For example:</p>
<pre><code class="lang-javascript">function getItemPriceById (id) {
    const result = this
        ::find(function () {
            return this.id === id;
        })
        ::map(prop(&quot;price&quot;))
        .next();

    if ( result.done ) { throw new Error(&quot;Item not found&quot;); }
    return result.value;
}
</code></pre>
<h2 id="modules">Modules</h2>
<p>Trine has been designed to be modular and decoupled from the ground up. Each exposed function is in its own module, so for example if you&#39;re using Webpack, instead of a huge library, you will only be transferring the needed functions to the client.</p>
<h2 id="installation">Installation</h2>
<p>Trine is available on <a href="https://www.npmjs.com/">npm</a>:</p>
<pre><code>npm install --save trine babel-runtime
</code></pre><p>At the moment, Trine requires you to also install the <code>babel-runtime</code> package, and depending on your usage, probably also some polyfills.</p>
<h2 id="license">License</h2>
<p>Trine is ISC licensed. See the <a href="https://github.com/jussi-kalliokoski/trine/blob/master/LICENSE">LICENSE</a> document for more information.</p>
<h2 id="contributing">Contributing</h2>
<p>The <a href="https://github.com/jussi-kalliokoski/trine/issues">issues</a> are a good place to start. Whether you&#39;re having a bug or fix one, have a knack for design and want to improve the appeal of Trine, want to improve the documentation, add a test case, propose a feature or just ask for help, please do. All (friendly) contributions are welcome, as long as they&#39;re not malicious.</p>

</body>
</html>